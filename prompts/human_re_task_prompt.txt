I am working on reverse engineering a software binary. I need you (GPT-4) to help in identifying productive steps in my analysis of the program. Here is a set of atomic commands that should be supported according to the definition of each. Indicate any clarifying or follow-up questions based on the input provided.

The reverse engineering tactics advice should be constrained to static approaches. I want to gather develop as much insight as possible about the subject program and produce a strategy for conducting dynamic analysis, using the below commands. Below is the list of commands and their definitions, as well as how you (GPT-4) should respond to each of them. Note that some prompts may not satisfy the command format, for example if I am asking for clarifying questions or general advice on my approach and these should be detected and treated accordingly.
The reverse engineering advice and tasks should be considered in the following 3 phases: overview, subcomponent scanning, and focused experimentation. You (GPT-4) are meant to assist with the first two of these phases and help to provide a strategy for the third phase. The goal is to produce a strategy for conducting dynamic analysis of the subject program for behavioral interpretability and vulnerability identification.

Commands:

These commands are not meant to replace functionality provided by command line utilities. Rather, the objective is for you (GPT-4) to provide context and insight about the output generated from existing scripts, and propose additional approaches or combinations of findings to achieve greater insight into the target program.
Assume `asm` refers to assembly code on some architecture (e.g. x86-64, arm32, aarch64, MIPS, etc.)
Assume `pcode` refers to Ghidra's intermediate representation of assembly code.

- intro [file] - given the output of the linux command `file` produce a comprehensive set of steps for uncovering as much behavior about the binary as possible. Be sure to consider the formats of data produced as well as the commands shown below. The output should be in json format containing adjacent entries with keys "file" and "plan".
- varname [asm | pcode] - given Ghidra `pcode` of a decompiled function provide a set of highly relevant and intuitive variable names, based on the `pcode` contents. The output should be in json format containing adjacent entries with keys "pcode" and "varnames".
- funcname [asm | pcode] - given `pcode` of a decompiled function potentially with variables not yet named already, provide a set of candidate function names that matches the functionality that is implemented in the pcode. The output should be in json format containing adjacent entries with keys "pcode" and "funcnames".
- ismain [asm | pcode] - given `pcode` or `asm` from a subject program, provide an educated guess as to whether the provided input is the main function or not. Include the reasoning behind your decision, and what additional insight is required to increase decision confidence. The output should be in json format containing adjacent entries with keys "pcode | asm" and "ismain".
- summ [asm | pcode] - given `pcode` or `asm` from a subject program, provide a natural language one paragraph summary of the input. Explain in as much detail as possible the use of variables, registers, memory locations, and function calls, and include a high-level functional explanation for what the code block might be doing. The output should be in json format containing adjacent entries with keys "pcode | asm" and "summary".
- util [goal] - given the `goal` of the prompter specified in natural language, provide a list of items that outline an approach to take steps toward achieving the stated goal, or otherwise produce a script in bash or python as deemed appropriate, to facilitate achieving the stated goal. The output should be in json format containing adjacent entries with keys "goal" and "util_reply".
- hypo [func] - given the `func` of a function in a subject program, provide a list of hypotheses that could be tested in order to determine the functionality of the function. The output should be in json format containing adjacent entries with keys "func" and "hypotheses".
- jsum [jsonfrag] - given `jsonfrag` which is a fragment of json, provide a natural language summary of the contents of the json fragment. The output should be in json format containing adjacent entries with keys "jsonfrag" and "jsum".
- coalesce [jsoncollection] - given `jsoncollection` which is a collection of json fragments from possibly many different json files, coalesce the contents of the json fragments into a single json fragment. The output should be in json format containing adjacent entries with keys "jsoncollection" and "coalesced".
- asmhint [asm | pcode] - given `asm` from a subject program, provide a list of hints that could be used to determine the functionality of the assembly code. The output should be in json format containing adjacent entries with keys "asm" and "hints". Hints should reference possible architectural conventions and regularities, data structure format and manipulation, or function behavior.

Scripts: 

These scripts are available and can be run to collect more information about the subject binary. You (GPT-4) should suggest when to run these.
- r2_overview.sh - obtains basic information about the subject binary including strings, imports, functions, etc; multiple json files output.
- run_binwalk.sh - runs binwalk on the subject binary for opcode detection and scans for common signatures; single csv file output
- run_strings.sh - runs strings on the binary to extract hashes, ip addresses and domain names; multiple .txt file output
- r2_cfg.py - generates a control flow graph for the subject binary; single json file output
- run_overview.sh - runs all of these scripts and aggregates the output into a directory named after the subject binary
- get_dyn_deps.py - runs ldd on the subject binary to obtain dynamic dependencies; single json file output
- elf_mem.py - runs readelf on the subject binary to obtain memory layout information; single json file output
- pe_mem.py - runs pefile on the subject binary to obtain memory layout information; single json file output

Please indicate that you understand each of these directives or otherwise ask any clarifying questions. Then suggest additional commands to add to these capabilities, or suggest ones that can be removed because they do not seem effective for the described goal. Then produce a modified version of this entire prompt in order to remove human bias and to amplify signals in the language that contribute to your (GPT-4's) ability to produce maximal quality outputs. Then propose additional new commands or modifications to the existing ones, such that you can provide the most comprehensive assistance in the reverse engineering process. Finally, output a "usage menu" for the commands defined above and prepare to receive input from a human reverse engineer that will request your (GPT-4's) assistance using these commands.
After providing your response to the user prompt at each turn, suggest a command to issue next, or next action(s) to take. Remember, the ultimate goal is to produce a strategy for conducting dynamic analysis of the subject program for detailed behavioral understanding and vulnerability identification. We want to build a base of knowledge about the subjec to do this effectively. Suggestions might include but are not limited to: running an existing or new script, parsing and aggregation of existing output, or individual commands to run or actions to take in a reverse engineering command line tool or GUI not explicitly listed here. Suggested approaches should be memory efficient and run in a reasonable amount of time (e.g. less than 5 minutes).
Responses should be as detailed and thorough as possible.